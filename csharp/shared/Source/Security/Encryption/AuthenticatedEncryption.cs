using System;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using SharedAssemblies.Core.Extensions;

namespace SharedAssemblies.Security.Encryption
{
	/// <summary>
	/// Encryption and Message Authentication static class.
	/// </summary>
	public static class AuthenticatedEncryption
	{
		#region Private Fields

		/// <summary>
		/// The minimum size of some encrypted data as it needs to include
		/// at least 20 bytes for the authentication code.
		/// </summary>
		private const int _minimumEncryptedSize = 20;

		#endregion

		/// <summary>
		/// Validate that data has not been altered.
		/// </summary>
		/// <param name="input">String Data used to generate an authentication code.</param>
		/// <param name="currentCode">
		/// Old Authentication code usually generated by GenerateAuthenticationCode()
		/// </param>
		/// <param name="validationKey">Validation key used by the HMAC algorithm.</param>
		/// <returns>true or false</returns>
		[SuppressMessage("SharedAssemblies.Tools.StyleCopRules.SafetyAndPerformanceAnalyzer",
			"ST5005:NoEmptyCatchBlocks",
			Justification = "Initialization of the key manager failures should not bleed information.")]
		public static bool ValidateAuthenticationCode(string input,
			string currentCode, string validationKey)
		{
			bool didValidate = false;

			try
			{
				didValidate = ValidateAuthenticationCode(
					Encoding.UTF8.GetBytes(input),
					Convert.FromBase64String(currentCode),
					Convert.FromBase64String(validationKey));
			}
			catch (Exception)
			{
				// This is allowed to prevent secure informatio from escaping
			}

			return didValidate;
		}

		/// <summary>
		/// Validate that data has not been altered.
		/// </summary>
		/// <param name="input">Binary Data used to generate an authentication code.</param>
		/// <param name="currentCode">
		/// Old Authentication code usually generated by GenerateAuthenticationCode()
		/// </param>
		/// <param name="validationKey">Validation key used by the HMAC algorithm.</param>
		/// <returns>true or false</returns>
		public static bool ValidateAuthenticationCode(byte[] input,
			byte[] currentCode, byte[] validationKey)
		{
			bool didValidate = false;

			if (!input.IsNullOrEmpty() && !currentCode.IsNullOrEmpty() 
				&& !validationKey.IsNullOrEmpty())
			{
				byte[] correctCode = EncryptionUtility.GenerateAuthenticationCode(
					input, validationKey);
				didValidate = currentCode.SequenceEqual(correctCode);
			}

			return didValidate;
		}

		/// <summary>
		/// Wrapper around EncryptThenAppendAuthenticationCode to work with strings
		/// instead of byte arrays.
		/// </summary>
		/// <param name="input">String data to encrypt and authenticate.</param>
		/// <param name="encryptionKey">Encryption key.</param>
		/// <param name="validationKey">Validation key.</param>
		/// <returns>Authenticated/Encrypted data or null if error</returns>
		[SuppressMessage("SharedAssemblies.Tools.StyleCopRules.SafetyAndPerformanceAnalyzer",
			"ST5005:NoEmptyCatchBlocks",
			Justification = "Initialization of the key manager failures should not bleed information.")]
		public static string EncryptThenAppendAuthenticationCode(string input,
			string encryptionKey, string validationKey)
		{
			string result = null;

			try
			{
				var encryptedData = EncryptThenAppendAuthenticationCode(
					Encoding.UTF8.GetBytes(input),
					Convert.FromBase64String(encryptionKey),
					Convert.FromBase64String(validationKey));
				result = Convert.ToBase64String(encryptedData);
			}
			catch (Exception)
			{
				// This is allowed to prevent secure informatio from escaping
			}

			return result;
		}

		/// <summary>
		/// Authenticated Encryption is the process of encrypting data, generating an authentication code for
		/// the encrypted data, and then appending the authentication code to the end of the encrypted data. The
		/// encryption process uses the encryption key and the validation process uses the validation key.
		/// </summary>
		/// <param name="input">String data to encrypt and authenticate.</param>
		/// <param name="encryptionKey">Encryption key.</param>
		/// <param name="validationKey">Validation key.</param>
		/// <returns>Authenticated/Encrypted data or null if error</returns>
		public static byte[] EncryptThenAppendAuthenticationCode(byte[] input,
			byte[] encryptionKey, byte[] validationKey)
		{
			byte[] result = null;

			if (!input.IsNullOrEmpty() && !encryptionKey.IsNullOrEmpty()
				&& !validationKey.IsNullOrEmpty())
			{
				byte[] encryptedData = EncryptionUtility.Encrypt(input, encryptionKey);
				byte[] authenticationCode = EncryptionUtility.GenerateAuthenticationCode(
					encryptedData, validationKey);
				result = encryptedData.Concat(authenticationCode).ToArray();
			}
			return result;
		}

        /// <summary>
        /// Wrapper around EncryptThenAppendAuthenticationCode to work with strings
        /// instead of byte arrays.
        /// </summary>
        /// <param name="input">String data to encrypt and authenticate.</param>
        /// <param name="encryptionKey">Encryption key.</param>
        /// <param name="validationKey">Validation key.</param>
        /// <returns>Authenticated/Encrypted data or null if error</returns>
		[SuppressMessage("SharedAssemblies.Tools.StyleCopRules.SafetyAndPerformanceAnalyzer",
			"ST5005:NoEmptyCatchBlocks",
			Justification = "Initialization of the key manager failures should not bleed information.")]
		public static string ValidateAuthenticationCodeThenDecrypt(string input,
            string encryptionKey, string validationKey)
        {
			string result = null;

			try
			{
				var decryptedData = ValidateAuthenticationCodeThenDecrypt(
					Convert.FromBase64String(input),
					Convert.FromBase64String(encryptionKey),
					Convert.FromBase64String(validationKey));
				result = Encoding.UTF8.GetString(decryptedData);
			}
			catch (Exception)
			{
				// This is allowed to prevent secure informatio from escaping
			}

			return result;
        }
        
		/// <summary>
		/// Validating an Authenticated Encryption (see EncryptThenAppendAuthenticationCode) is the process of
		/// validating the authentication code for an encypted piece of data, and if validated successfully,
		/// this method will decrypt the data using the encryption key.
		/// </summary>
		/// <param name="input">Binary data to validate and decrypt.</param>
		/// <param name="encryptionKey">Encryption key.</param>
		/// <param name="validationKey">Validation key.</param>
		/// <returns>Unencrypted string data or null if error.</returns>
		public static byte[] ValidateAuthenticationCodeThenDecrypt(
			byte[] input, byte[] encryptionKey, byte[] validationKey)
		{
			byte[] result = null;

			if (!input.IsNullOrEmpty() && !encryptionKey.IsNullOrEmpty()
				&& !validationKey.IsNullOrEmpty() && input.Length >= _minimumEncryptedSize)
			{
				int position = input.Length - _minimumEncryptedSize;
				byte[] encryptedData = input.Take(position).ToArray();
				byte[] authenticationCode = input.Skip(position).ToArray();

				if (ValidateAuthenticationCode(encryptedData, authenticationCode, validationKey))
				{
					result = EncryptionUtility.Decrypt(encryptedData, encryptionKey);
				}
			}

			return result;
		}
	}
}
