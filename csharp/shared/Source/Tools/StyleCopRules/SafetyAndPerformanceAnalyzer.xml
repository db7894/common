<?xml version="1.0" encoding="utf-8" ?>
<SourceAnalyzer Name="Bashwork Safety and Performance Rules">
	<Description>
		Bashwork custom rules dictating safety and performance items in C#.
	</Description>
	<Rules>
		<Rule Name="DoNotManuallyGarbageCollect" CheckId="ST5001">
			<Context>Do not manually invoke garbage collection.</Context>
			<Description>
				When you manually invoke garbage collection, you are denying the CLR its 
				chance to optimize garbage collection to have the least performance impact.  In general,
				you should always allow the CLR to collect garbage when it feels the need.  It has been
				optimized already to be of minimal impact, and manually calling it neither guarantees that
				all garbage will be collected nor gains performance.
				This is covered in C# Coding Standard 2.6.5.
			</Description>
		</Rule>
		<Rule Name="NoAssignmentInConditionals" CheckId="ST5002">
			<Context>No assignments ({0}) inside of {1}.</Context>
			<Description>
				Assignments inside of conditional expressions are error prone as it may be difficult
				to evaluate whether a side-effect will occur or not and in what order.  As a result,
				assignments should never be in conditional expressions but should be assigned first
				to another variable, and the conditional should then test that variable.
				This is covered in C# Coding Standard 2.6.14.
			</Description>
		</Rule>
		<Rule Name="NoGotos" CheckId="ST5003">
			<Context>Never use Goto, refactor instead to eliminate need.</Context>
			<Description>
				Gotos are inherently less readable and tend to create spaghetti code.  As a result
				you should always refactor them to eliminate the need.
				This is covered in C# Coding Standard 3.1.8.
			</Description>
		</Rule>
		<Rule Name="NoUnsafeBlocks" CheckId="ST5004">
			<Context>Unsafe blocks are inherently unsafe, you should avoid at all costs.</Context>
			<Description>
				The performance gains acheived by writing an unsafe block are often negligible at 
				best.  Whenever an unsafe region is used, it should be isolated in a well-tested library
				and then made available as a usable assembly.  This must be done on an exceptional
				basis only and must be approved.
				This is covered in C# Coding Standard 3.2.1.
			</Description>
		</Rule>
		<Rule Name="NoEmptyCatchBlocks" CheckId="ST5005">
			<Context>Never catch and do nothing, log or rethrow.</Context>
			<Description>
				A safe application never catches and hides an exception, all exceptions should be
				logged at the minimum, though a more proper handling is preferred depending on the
				situation.  If there is truly a need to consume the exceptions with no action, 
				you may programatically suppress this rule, but you will need to explain why.
				This is covered in C# Coding Standard 2.7.3.
			</Description>
		</Rule>
		<Rule Name="NoCatchAlls" CheckId="ST5006">
			<Context>Catch-all is too broad of a catch to consume exceptions, refine with exception filtering.</Context>
			<Description>
				Using catch with no exceptions listed is a catch-all that catches everything
				which is far too broard (and unnecessary since .Net 2.0) when consuming the exception.  
				Use exception filtering instead or rethrow once logging or other actions are taken.
				This is covered in C# Coding Standard 2.7.5 and is enforced by Application Security reviews.
			</Description>
		</Rule>
		<Rule Name="NoCatchSystemException" CheckId="ST5007">
			<Context>Catching System.Exception is too broad, refine with exception filtering.</Context>
			<Description>
				Using catch on System.Exception is a catch-all that catches everything
				which is far too broard when consuming the exception.
				Use exception filtering instead or rethrow once logging or other actions are taken.
				This is covered in C# Coding Standard 2.7.5 and is enforced by Application Security reviews.
			</Description>
		</Rule>
		<Rule Name="UseEmptyThrowToRethrow" CheckId="ST5008">
			<Context>Never manually re-throw an exception, use the empty throw.</Context>
			<Description>
				When re-throwing an exception, do not re-throw the caught exception identifier as this
				destroys the existing stack trace.  Use the empty "throw;" clause instead.
				This is covered in C# Coding Standard 2.7.6.
			</Description>
		</Rule>
		<Rule Name="DoNotManuallyThrowSystemException" CheckId="ST5009">
			<Context>Never manually throw system exception {0}.</Context>
			<Description>
				You should only ever throw application exceptions, most SystemException derrivatives
				are reserved for the framework itself such as NullReferenceException, prefer to throw
				custom exceptions or ArgumentXxxExceptions instead.
				This is covered in C# Coding Standard 2.7.6.
			</Description>
		</Rule>
		<Rule Name="DoNotHideParentMember" CheckId="ST5010">
			<Context>Do not hide parent {0}, override instead.</Context>
			<Description>
				Hiding is problematic at best, when you hide you only switch the behavior for 
				references explicit to your class and not through any base class or interface.  As 
				a result, you should avoid hiding at all costs.
				This is covered in C# Coding Standard 4.2.7.
			</Description>
		</Rule>
		<Rule Name="DoNotExit" CheckId="ST5011">
			<Context>Do not manually exit program by calling Environment.Exit().</Context>
			<Description>
				Forcing an exit of an application is a very bad practice, it basically skips all 
				cleanup steps and just terminates the application which can leave everythign in
				an indeterminate state.
				This is covered in C# Coding Standard 4.2.7.
			</Description>
		</Rule>
		<Rule Name="DoNotSupressThreadAbortException" CheckId="ST5012">
			<Context>Never consume or reset a ThreadAbortException.</Context>
			<Description>
				Whenever ThreadAbortException is caught, you cannot consume this exception.  Even if you
				do not rethrow, the exception automatically rethrows.  As a result, you are better protected
				by putting your resources in IDisposable using blocks or finally sections than attempting
				to catch this exception explicitly.  And resetting this exception or attempting to consume it
				is very bad form as generally speaking something very bad must have triggered an abort and to
				not then abort could lead to unpredictable state.
				This is covered in C# Coding Standard 4.2.7.
			</Description>
		</Rule>
		
	</Rules>
</SourceAnalyzer>
